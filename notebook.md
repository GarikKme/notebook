# С# конспект


## Lesson 3

не перегружать интерфейсы ( не создавать много наследований интерфейсов)

12м -> (IAction)baseAction1).Move(); - пример возможности языка ( сахар ) пишем когда явно указана реализация метода в интерфейсе - void ISchool.Move() = небозапасный вариант выполнения

ICloneable interface - возможность делать глубокую копию ( стандартный интерфейс для использования )

MemberwiseClone() -  стандартный метод копирования для поверхносного копирования

Для глубокого копирования - public object Clone() => new Person(Name, Age, new Company(Work.Name))


IComparable interface - для сравнения объектов например машин

`Public interface IComparable<in T>{<br>int CompareTo(T? Other) }`

В нем мы выбираем по какому параметру будут сравниваться объекты и сортировать в дальнейшем.


47 - IEnumerable interface - интерфейс для перебора объектов, делаем когда нужно проходиться по объекту через foreach цикл что удобно и привычно!
`class WeekEnumerator : IEnumerator
{
string[] days;
int position = -1;
public WeekEnumerator(string[] days) => this.days = days;`



1:00 Generators and iterators
Генераторы нужны чтоб возвращать часть файла к примеру по частям и каждый кусочек(чанки) будет получен на каждой итерации. Всегда получаем только кусочек, полную коллекцию не получаем в определенной момент времени.

`class Numbers
{
public IEnumerator<int> GetEnumerator()
{
for (int i = 0; i < 6; i++)
{
yield return i*i;
}
}
}`


1:32 Extension методы - используем для перевода из одного типа данных в другой, всегда создаем статическим методом, первым аргументом	принимает тот тип который хотим расширить


1:48 partial classes<br>

Класс который распределяется в разных файлах. Просто разделение логики класса.
Partial методы не имеют модификаторов доступа, out параметров, не имеют virtual, override, sealed, new, extern и всегда void.


1:55 abstract classes
Абстрактный клас существует для того чтоб сделать каркас свойств и методов которые реализуют его наследники, от него не можем создать объект абстрактного класса. Так же он может иметь и обычные методы которые существуют просто для какой-то реализации. Их не нужно реализовывать наследникам.

Разница между абстрактным классом и интерфейсом - у класса могут быть как абстрактные методы и поля которые обязательные для выполнения в наследнике так и простые, у интерфейса нет только контракт которые нужно реализовывать, класс не имеет множественного наследованния

