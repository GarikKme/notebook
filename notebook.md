# С# конспект

## Lesson 3

не перегружать интерфейсы ( не создавать много наследований интерфейсов)

12м -> (IAction)baseAction1).Move(); - пример возможности языка ( сахар ) пишем когда явно указана реализация метода в интерфейсе - void ISchool.Move() = небозапасный вариант выполнения

ICloneable interface - возможность делать глубокую копию ( стандартный интерфейс для использования )

MemberwiseClone() - стандартный метод копирования для поверхносного копирования

Для глубокого копирования - public object Clone() => new Person(Name, Age, new Company(Work.Name))

IComparable interface - для сравнения объектов например машин

`Public interface IComparable<in T>{<br>int CompareTo(T? Other) }`

В нем мы выбираем по какому параметру будут сравниваться объекты и сортировать в дальнейшем.

47 - IEnumerable interface - интерфейс для перебора объектов, делаем когда нужно проходиться по объекту через foreach цикл что удобно и привычно!
`class WeekEnumerator : IEnumerator
{
string[] days;
int position = -1;
public WeekEnumerator(string[] days) => this.days = days;`

1:00 Generators and iterators
Генераторы нужны чтоб возвращать часть файла к примеру по частям и каждый кусочек(чанки) будет получен на каждой итерации. Всегда получаем только кусочек, полную коллекцию не получаем в определенной момент времени.

`class Numbers
{
public IEnumerator<int> GetEnumerator()
{
for (int i = 0; i < 6; i++)
{
yield return i*i;
}
}
}`

1:32 Extension методы - используем для перевода из одного типа данных в другой, всегда создаем статическим методом, первым аргументом принимает тот тип который хотим расширить

1:48 partial classes<br>

Класс который распределяется в разных файлах. Просто разделение логики класса.
Partial методы не имеют модификаторов доступа, out параметров, не имеют virtual, override, sealed, new, extern и всегда void.

1:55 abstract classes
Абстрактный клас существует для того чтоб сделать каркас свойств и методов которые реализуют его наследники, от него не можем создать объект абстрактного класса. Так же он может иметь и обычные методы которые существуют просто для какой-то реализации. Их не нужно реализовывать наследникам.

Разница между абстрактным классом и интерфейсом - у класса могут быть как абстрактные методы и поля которые обязательные для выполнения в наследнике так и простые, у интерфейса нет только контракт которые нужно реализовывать, класс не имеет множественного наследованния

## Lesson 4 Overload operators

можно перегрузить

    унарные операторы +x, -x, !x, ~x, ++, --, true, false

    бинарные операторы +, -, *, /, %

    операции сравнения ==, !=, <, >, <=, >=

    поразрядные операторы &, |, ^, <<, >>

    логические операторы &&, ||

     нужно определять парами

    == и !=

    < и >

    <= и >=

Можно перегрузить операторы чтоб сравнивать обьекты для своих нужд;

## Lesson 5 Generic interfaces

Что такое Generic (Обобщения)?
Вместо того, чтобы писать код под каждый тип данных, мы создаём шаблон, где тип будет параметром. Это похоже на классическую посуду: не важно, из чего сделана — можно налить воду, сок или чай. Главное — универсальность.
`public class Box<T>
{
private T \_item

    public void Put(T item)
    {
        _item = item;
    }

    public T Get()
    {
        return _item;
    }

}`

## Lesson 6 SOLID Principles

SOLID - это набор принципов для разработки ПО.
Помогают создавать код масштабируемым и поддерживаемым.
Важно научиться понимать и применять особенно в больших пректах но и не перегибать с ними.

* Single Responsibility Principle (Принцип єдиного обов'язку)
* Open/Closed Principle (Принцип відкритості/закритості)
* Liskov Substitution Principle (Принцип підстановки Лісков)
* Interface Segregation Principle (Принцип розподілу інтерфейсів)
* Dependency Inversion Principle (Принцип інверсії залежностей)

KISS - чем проще тем понятней и лучше надо писать код
DRY - не писать повторяемый код
YAGNI - не надо писать код который не нужен в приложении
